   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 1
  10              		.eabi_attribute 34, 1
  11              		.eabi_attribute 18, 4
  12              		.file	"base64url.c"
  13              		.text
  14              	.Ltext0:
  15              		.cfi_sections	.debug_frame
  16              		.section	.text.base64_encode,"ax",%progbits
  17              		.align	1
  18              		.global	base64_encode
  19              		.arch armv7e-m
  20              		.syntax unified
  21              		.thumb
  22              		.thumb_func
  23              		.fpu fpv4-sp-d16
  25              	base64_encode:
  26              	.LVL0:
  27              	.LFB1:
  28              		.file 1 "base64url.c"
   1:base64url.c   **** /* base64url.c -- Encode binary data using printable characters.
   2:base64url.c   ****    Copyright (C) 1999, 2000, 2001, 2004, 2005, 2006 Free Software
   3:base64url.c   ****    Foundation, Inc.
   4:base64url.c   **** 
   5:base64url.c   ****    This program is free software; you can redistribute it and/or modify
   6:base64url.c   ****    it under the terms of the GNU General Public License as published by
   7:base64url.c   ****    the Free Software Foundation; either version 2, or (at your option)
   8:base64url.c   ****    any later version.
   9:base64url.c   **** 
  10:base64url.c   ****    This program is distributed in the hope that it will be useful,
  11:base64url.c   ****    but WITHOUT ANY WARRANTY; without even the implied warranty of
  12:base64url.c   ****    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  13:base64url.c   ****    GNU General Public License for more details.
  14:base64url.c   **** 
  15:base64url.c   ****    You should have received a copy of the GNU General Public License
  16:base64url.c   ****    along with this program; if not, write to the Free Software Foundation,
  17:base64url.c   ****    Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
  18:base64url.c   **** 
  19:base64url.c   **** /* Written by Simon Josefsson.  Partially adapted from GNU MailUtils
  20:base64url.c   ****  * (mailbox/filter_trans.c, as of 2004-11-28).  Improved by review
  21:base64url.c   ****  * from Paul Eggert, Bruno Haible, and Stepan Kasal.
  22:base64url.c   ****  *
  23:base64url.c   ****  * See also RFC 3548 <http://www.ietf.org/rfc/rfc3548.txt>.
  24:base64url.c   ****  *
  25:base64url.c   ****  * Be careful with error checking.  Here is how you would typically
  26:base64url.c   ****  * use these functions:
  27:base64url.c   ****  *
  28:base64url.c   ****  * bool ok = base64_decode_alloc (in, inlen, &out, &outlen);
  29:base64url.c   ****  * if (!ok)
  30:base64url.c   ****  *   FAIL: input was not valid base64
  31:base64url.c   ****  * if (out == NULL)
  32:base64url.c   ****  *   FAIL: memory allocation error
  33:base64url.c   ****  * OK: data in OUT/OUTLEN
  34:base64url.c   ****  *
  35:base64url.c   ****  * size_t outlen = base64_encode_alloc (in, inlen, &out);
  36:base64url.c   ****  * if (out == NULL && outlen == 0 && inlen != 0)
  37:base64url.c   ****  *   FAIL: input too long
  38:base64url.c   ****  * if (out == NULL)
  39:base64url.c   ****  *   FAIL: memory allocation error
  40:base64url.c   ****  * OK: data in OUT/OUTLEN.
  41:base64url.c   ****  *
  42:base64url.c   ****  */
  43:base64url.c   **** 
  44:base64url.c   **** /* Adapted to URL safe alphabet by Florian Wilde on 2017-12-04
  45:base64url.c   ****  */
  46:base64url.c   **** 
  47:base64url.c   **** //#include <config.h>
  48:base64url.c   **** #include <stdbool.h>
  49:base64url.c   **** 
  50:base64url.c   **** /* Get prototype. */
  51:base64url.c   **** #include "base64url.h"
  52:base64url.c   **** 
  53:base64url.c   **** /* Get malloc. */
  54:base64url.c   **** #include <stdlib.h>
  55:base64url.c   **** 
  56:base64url.c   **** /* Get UCHAR_MAX. */
  57:base64url.c   **** #include <limits.h>
  58:base64url.c   **** 
  59:base64url.c   **** /* C89 compliant way to cast 'char' to 'unsigned char'. */
  60:base64url.c   **** static inline unsigned char
  61:base64url.c   **** to_uchar (char ch)
  62:base64url.c   **** {
  63:base64url.c   ****   return ch;
  64:base64url.c   **** }
  65:base64url.c   **** 
  66:base64url.c   **** /* Base64 encode IN array of size INLEN into OUT array of size OUTLEN.
  67:base64url.c   ****    If OUTLEN is less than BASE64_LENGTH(INLEN), write as many bytes as
  68:base64url.c   ****    possible.  If OUTLEN is larger than BASE64_LENGTH(INLEN), also zero
  69:base64url.c   ****    terminate the output buffer. */
  70:base64url.c   **** void
  71:base64url.c   **** base64_encode (const char *restrict in, size_t inlen,
  72:base64url.c   **** 	       char *restrict out, size_t outlen)
  73:base64url.c   **** {
  29              		.loc 1 73 1 view -0
  30              		.cfi_startproc
  31              		@ args = 0, pretend = 0, frame = 0
  32              		@ frame_needed = 0, uses_anonymous_args = 0
  74:base64url.c   ****   static const char b64str[64] =
  33              		.loc 1 74 3 view .LVU1
  75:base64url.c   ****     "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
  76:base64url.c   **** 
  77:base64url.c   ****   while (inlen && outlen)
  34              		.loc 1 77 3 view .LVU2
  35              		.loc 1 77 9 view .LVU3
  36 0000 0029     		cmp	r1, #0
  37 0002 44D0     		beq	.L2
  73:base64url.c   ****   static const char b64str[64] =
  38              		.loc 1 73 1 is_stmt 0 view .LVU4
  39 0004 F0B5     		push	{r4, r5, r6, r7, lr}
  40              	.LCFI0:
  41              		.cfi_def_cfa_offset 20
  42              		.cfi_offset 4, -20
  43              		.cfi_offset 5, -16
  44              		.cfi_offset 6, -12
  45              		.cfi_offset 7, -8
  46              		.cfi_offset 14, -4
  47 0006 0F46     		mov	r7, r1
  48              		.loc 1 77 16 view .LVU5
  49 0008 002B     		cmp	r3, #0
  50 000a 4CD0     		beq	.L1
  78:base64url.c   ****     {
  79:base64url.c   ****       *out++ = b64str[(to_uchar (in[0]) >> 2) & 0x3f];
  51              		.loc 1 79 7 is_stmt 1 view .LVU6
  52              		.loc 1 79 24 is_stmt 0 view .LVU7
  53 000c 0178     		ldrb	r1, [r0]	@ zero_extendqisi2
  54              	.LVL1:
  63:base64url.c   **** }
  55              		.loc 1 63 3 is_stmt 1 view .LVU8
  56              		.loc 1 79 47 is_stmt 0 view .LVU9
  57 000e 8C08     		lsrs	r4, r1, #2
  58              		.loc 1 79 14 view .LVU10
  59 0010 2A4D     		ldr	r5, .L18
  60 0012 2C5D     		ldrb	r4, [r5, r4]	@ zero_extendqisi2
  61 0014 1470     		strb	r4, [r2]
  80:base64url.c   ****       if (!--outlen)
  62              		.loc 1 80 7 is_stmt 1 view .LVU11
  63              	.LVL2:
  64              		.loc 1 80 10 is_stmt 0 view .LVU12
  65 0016 012B     		cmp	r3, #1
  66 0018 45D0     		beq	.L1
  81:base64url.c   **** 	break;
  82:base64url.c   ****       *out++ = b64str[((to_uchar (in[0]) << 4)
  67              		.loc 1 82 22 view .LVU13
  68 001a 2C46     		mov	r4, r5
  83:base64url.c   **** 		       + (--inlen ? to_uchar (in[1]) >> 4 : 0))
  84:base64url.c   **** 		      & 0x3f];
  85:base64url.c   ****       if (!--outlen)
  86:base64url.c   **** 	break;
  87:base64url.c   ****       *out++ =
  69              		.loc 1 87 14 view .LVU14
  70 001c 3D26     		movs	r6, #61
  83:base64url.c   **** 		       + (--inlen ? to_uchar (in[1]) >> 4 : 0))
  71              		.loc 1 83 45 view .LVU15
  72 001e 0025     		movs	r5, #0
  73 0020 0AE0     		b	.L4
  74              	.LVL3:
  75              	.L8:
  88:base64url.c   **** 	(inlen
  89:base64url.c   **** 	 ? b64str[((to_uchar (in[1]) << 2)
  90:base64url.c   **** 		   + (--inlen ? to_uchar (in[2]) >> 6 : 0))
  91:base64url.c   **** 		  & 0x3f]
  92:base64url.c   **** 	 : '=');
  93:base64url.c   ****       if (!--outlen)
  94:base64url.c   **** 	break;
  95:base64url.c   ****       *out++ = inlen ? b64str[to_uchar (in[2]) & 0x3f] : '=';
  96:base64url.c   ****       if (!--outlen)
  97:base64url.c   **** 	break;
  98:base64url.c   ****       if (inlen)
  99:base64url.c   **** 	inlen--;
 100:base64url.c   ****       if (inlen)
 101:base64url.c   **** 	in += 3;
  76              		.loc 1 101 2 is_stmt 1 view .LVU16
  77:base64url.c   ****     {
  77              		.loc 1 77 9 view .LVU17
  79:base64url.c   ****       if (!--outlen)
  78              		.loc 1 79 7 view .LVU18
  79:base64url.c   ****       if (!--outlen)
  79              		.loc 1 79 24 is_stmt 0 view .LVU19
  80 0022 10F8031F 		ldrb	r1, [r0, #3]!	@ zero_extendqisi2
  81              	.LVL4:
  63:base64url.c   **** }
  82              		.loc 1 63 3 is_stmt 1 view .LVU20
  79:base64url.c   ****       if (!--outlen)
  83              		.loc 1 79 47 is_stmt 0 view .LVU21
  84 0026 4FEA910C 		lsr	ip, r1, #2
  79:base64url.c   ****       if (!--outlen)
  85              		.loc 1 79 14 view .LVU22
  86 002a 14F80CC0 		ldrb	ip, [r4, ip]	@ zero_extendqisi2
  87 002e 82F800C0 		strb	ip, [r2]
  80:base64url.c   **** 	break;
  88              		.loc 1 80 7 is_stmt 1 view .LVU23
  89              	.LVL5:
  80:base64url.c   **** 	break;
  90              		.loc 1 80 10 is_stmt 0 view .LVU24
  91 0032 052B     		cmp	r3, #5
  92 0034 37D0     		beq	.L1
  96:base64url.c   **** 	break;
  93              		.loc 1 96 10 view .LVU25
  94 0036 7346     		mov	r3, lr
  95              	.LVL6:
  96              	.L4:
  82:base64url.c   **** 		       + (--inlen ? to_uchar (in[1]) >> 4 : 0))
  97              		.loc 1 82 7 is_stmt 1 view .LVU26
  63:base64url.c   **** }
  98              		.loc 1 63 3 view .LVU27
  82:base64url.c   **** 		       + (--inlen ? to_uchar (in[1]) >> 4 : 0))
  99              		.loc 1 82 42 is_stmt 0 view .LVU28
 100 0038 0901     		lsls	r1, r1, #4
 101              	.LVL7:
  83:base64url.c   **** 		      & 0x3f];
 102              		.loc 1 83 45 view .LVU29
 103 003a 012F     		cmp	r7, #1
 104 003c 34D0     		beq	.L5
 105              	.LVL8:
  63:base64url.c   **** }
 106              		.loc 1 63 3 is_stmt 1 discriminator 1 view .LVU30
  83:base64url.c   **** 		      & 0x3f];
 107              		.loc 1 83 40 is_stmt 0 discriminator 1 view .LVU31
 108 003e 90F801C0 		ldrb	ip, [r0, #1]	@ zero_extendqisi2
  83:base64url.c   **** 		      & 0x3f];
 109              		.loc 1 83 10 discriminator 1 view .LVU32
 110 0042 01EB1C11 		add	r1, r1, ip, lsr #4
  84:base64url.c   ****       if (!--outlen)
 111              		.loc 1 84 9 discriminator 1 view .LVU33
 112 0046 01F03F01 		and	r1, r1, #63
  82:base64url.c   **** 		       + (--inlen ? to_uchar (in[1]) >> 4 : 0))
 113              		.loc 1 82 14 discriminator 1 view .LVU34
 114 004a 615C     		ldrb	r1, [r4, r1]	@ zero_extendqisi2
 115 004c 5170     		strb	r1, [r2, #1]
  85:base64url.c   **** 	break;
 116              		.loc 1 85 7 is_stmt 1 discriminator 1 view .LVU35
 117              	.LVL9:
  85:base64url.c   **** 	break;
 118              		.loc 1 85 10 is_stmt 0 discriminator 1 view .LVU36
 119 004e 022B     		cmp	r3, #2
 120 0050 29D0     		beq	.L1
 121              	.LVL10:
  63:base64url.c   **** }
 122              		.loc 1 63 3 is_stmt 1 view .LVU37
  89:base64url.c   **** 		   + (--inlen ? to_uchar (in[2]) >> 6 : 0))
 123              		.loc 1 89 14 is_stmt 0 view .LVU38
 124 0052 6146     		mov	r1, ip
  89:base64url.c   **** 		   + (--inlen ? to_uchar (in[2]) >> 6 : 0))
 125              		.loc 1 89 31 view .LVU39
 126 0054 8900     		lsls	r1, r1, #2
 127              	.LVL11:
  90:base64url.c   **** 		  & 0x3f]
 128              		.loc 1 90 41 view .LVU40
 129 0056 023F     		subs	r7, r7, #2
 130              	.LVL12:
  63:base64url.c   **** }
 131              		.loc 1 63 3 is_stmt 1 view .LVU41
  90:base64url.c   **** 		  & 0x3f]
 132              		.loc 1 90 36 is_stmt 0 view .LVU42
 133 0058 1ABF     		itte	ne
 134 005a 90F802C0 		ldrbne	ip, [r0, #2]	@ zero_extendqisi2
  90:base64url.c   **** 		  & 0x3f]
 135              		.loc 1 90 41 view .LVU43
 136 005e 4FEA9C1C 		lsrne	ip, ip, #6
 137 0062 AC46     		moveq	ip, r5
  90:base64url.c   **** 		  & 0x3f]
 138              		.loc 1 90 6 view .LVU44
 139 0064 6144     		add	r1, r1, ip
  91:base64url.c   **** 	 : '=');
 140              		.loc 1 91 5 view .LVU45
 141 0066 01F03F01 		and	r1, r1, #63
  87:base64url.c   **** 	(inlen
 142              		.loc 1 87 14 view .LVU46
 143 006a 615C     		ldrb	r1, [r4, r1]	@ zero_extendqisi2
 144              	.LVL13:
 145              	.L11:
  87:base64url.c   **** 	(inlen
 146              		.loc 1 87 14 discriminator 3 view .LVU47
 147 006c 9170     		strb	r1, [r2, #2]
  93:base64url.c   **** 	break;
 148              		.loc 1 93 7 is_stmt 1 discriminator 3 view .LVU48
 149              	.LVL14:
  93:base64url.c   **** 	break;
 150              		.loc 1 93 10 is_stmt 0 discriminator 3 view .LVU49
 151 006e 032B     		cmp	r3, #3
 152 0070 19D0     		beq	.L1
  95:base64url.c   ****       if (!--outlen)
 153              		.loc 1 95 7 is_stmt 1 view .LVU50
  95:base64url.c   ****       if (!--outlen)
 154              		.loc 1 95 14 is_stmt 0 view .LVU51
 155 0072 87B1     		cbz	r7, .L7
 156              	.LVL15:
  63:base64url.c   **** }
 157              		.loc 1 63 3 is_stmt 1 discriminator 1 view .LVU52
  63:base64url.c   **** }
 158              		.loc 1 63 3 is_stmt 0 discriminator 1 view .LVU53
 159 0074 0432     		adds	r2, r2, #4
 160              	.LVL16:
  95:base64url.c   ****       if (!--outlen)
 161              		.loc 1 95 48 discriminator 1 view .LVU54
 162 0076 8178     		ldrb	r1, [r0, #2]	@ zero_extendqisi2
 163 0078 01F03F01 		and	r1, r1, #63
  95:base64url.c   ****       if (!--outlen)
 164              		.loc 1 95 14 discriminator 1 view .LVU55
 165 007c 615C     		ldrb	r1, [r4, r1]	@ zero_extendqisi2
 166 007e 02F8011C 		strb	r1, [r2, #-1]
  96:base64url.c   **** 	break;
 167              		.loc 1 96 7 is_stmt 1 discriminator 1 view .LVU56
 168              	.LVL17:
  96:base64url.c   **** 	break;
 169              		.loc 1 96 10 is_stmt 0 discriminator 1 view .LVU57
 170 0082 B3F1040E 		subs	lr, r3, #4
 171              	.LVL18:
  96:base64url.c   **** 	break;
 172              		.loc 1 96 10 discriminator 1 view .LVU58
 173 0086 0ED0     		beq	.L1
  99:base64url.c   ****       if (inlen)
 174              		.loc 1 99 2 is_stmt 1 view .LVU59
 175              	.LVL19:
 100:base64url.c   **** 	in += 3;
 176              		.loc 1 100 7 view .LVU60
 100:base64url.c   **** 	in += 3;
 177              		.loc 1 100 10 is_stmt 0 view .LVU61
 178 0088 013F     		subs	r7, r7, #1
 179              	.LVL20:
 100:base64url.c   **** 	in += 3;
 180              		.loc 1 100 10 view .LVU62
 181 008a CAD1     		bne	.L8
 182 008c 09E0     		b	.L9
 183              	.LVL21:
 184              	.L2:
 185              	.LCFI1:
 186              		.cfi_def_cfa_offset 0
 187              		.cfi_restore 4
 188              		.cfi_restore 5
 189              		.cfi_restore 6
 190              		.cfi_restore 7
 191              		.cfi_restore 14
 102:base64url.c   ****     }
 103:base64url.c   **** 
 104:base64url.c   ****   if (outlen)
 192              		.loc 1 104 3 is_stmt 1 view .LVU63
 193              		.loc 1 104 6 is_stmt 0 view .LVU64
 194 008e 0BB1     		cbz	r3, .L15
 195              	.LVL22:
 105:base64url.c   ****     *out = '\0';
 196              		.loc 1 105 5 is_stmt 1 view .LVU65
 197              		.loc 1 105 10 is_stmt 0 view .LVU66
 198 0090 0023     		movs	r3, #0
 199 0092 1370     		strb	r3, [r2]
 200              	.L15:
 201              		.loc 1 105 10 view .LVU67
 202 0094 7047     		bx	lr
 203              	.LVL23:
 204              	.L7:
 205              	.LCFI2:
 206              		.cfi_def_cfa_offset 20
 207              		.cfi_offset 4, -20
 208              		.cfi_offset 5, -16
 209              		.cfi_offset 6, -12
 210              		.cfi_offset 7, -8
 211              		.cfi_offset 14, -4
 212              		.loc 1 105 10 view .LVU68
 213 0096 0432     		adds	r2, r2, #4
 214              	.LVL24:
  95:base64url.c   ****       if (!--outlen)
 215              		.loc 1 95 14 view .LVU69
 216 0098 3D21     		movs	r1, #61
 217 009a 02F8011C 		strb	r1, [r2, #-1]
  96:base64url.c   **** 	break;
 218              		.loc 1 96 7 is_stmt 1 view .LVU70
 219              	.LVL25:
  96:base64url.c   **** 	break;
 220              		.loc 1 96 10 is_stmt 0 view .LVU71
 221 009e 042B     		cmp	r3, #4
 222 00a0 01D0     		beq	.L1
 223              	.LVL26:
 224              	.L9:
 225              		.loc 1 105 5 is_stmt 1 view .LVU72
 226              		.loc 1 105 10 is_stmt 0 view .LVU73
 227 00a2 0023     		movs	r3, #0
 228 00a4 1370     		strb	r3, [r2]
 229              	.LVL27:
 230              	.L1:
 106:base64url.c   **** }
 231              		.loc 1 106 1 view .LVU74
 232 00a6 F0BD     		pop	{r4, r5, r6, r7, pc}
 233              	.LVL28:
 234              	.L5:
  84:base64url.c   ****       if (!--outlen)
 235              		.loc 1 84 9 view .LVU75
 236 00a8 01F03F01 		and	r1, r1, #63
  82:base64url.c   **** 		       + (--inlen ? to_uchar (in[1]) >> 4 : 0))
 237              		.loc 1 82 14 view .LVU76
 238 00ac 615C     		ldrb	r1, [r4, r1]	@ zero_extendqisi2
 239 00ae 5170     		strb	r1, [r2, #1]
  85:base64url.c   **** 	break;
 240              		.loc 1 85 7 is_stmt 1 view .LVU77
 241              	.LVL29:
  85:base64url.c   **** 	break;
 242              		.loc 1 85 10 is_stmt 0 view .LVU78
 243 00b0 022B     		cmp	r3, #2
 244 00b2 F8D0     		beq	.L1
  87:base64url.c   **** 	(inlen
 245              		.loc 1 87 14 view .LVU79
 246 00b4 3146     		mov	r1, r6
  83:base64url.c   **** 		      & 0x3f];
 247              		.loc 1 83 45 view .LVU80
 248 00b6 2F46     		mov	r7, r5
 249              	.LVL30:
  83:base64url.c   **** 		      & 0x3f];
 250              		.loc 1 83 45 view .LVU81
 251 00b8 D8E7     		b	.L11
 252              	.L19:
 253 00ba 00BF     		.align	2
 254              	.L18:
 255 00bc 00000000 		.word	.LANCHOR0
 256              		.cfi_endproc
 257              	.LFE1:
 259              		.section	.text.base64_encode_alloc,"ax",%progbits
 260              		.align	1
 261              		.global	base64_encode_alloc
 262              		.syntax unified
 263              		.thumb
 264              		.thumb_func
 265              		.fpu fpv4-sp-d16
 267              	base64_encode_alloc:
 268              	.LVL31:
 269              	.LFB2:
 107:base64url.c   **** 
 108:base64url.c   **** /* Allocate a buffer and store zero terminated base64 encoded data
 109:base64url.c   ****    from array IN of size INLEN, returning BASE64_LENGTH(INLEN), i.e.,
 110:base64url.c   ****    the length of the encoded data, excluding the terminating zero.  On
 111:base64url.c   ****    return, the OUT variable will hold a pointer to newly allocated
 112:base64url.c   ****    memory that must be deallocated by the caller.  If output string
 113:base64url.c   ****    length would overflow, 0 is returned and OUT is set to NULL.  If
 114:base64url.c   ****    memory allocation failed, OUT is set to NULL, and the return value
 115:base64url.c   ****    indicates length of the requested memory block, i.e.,
 116:base64url.c   ****    BASE64_LENGTH(inlen) + 1. */
 117:base64url.c   **** size_t
 118:base64url.c   **** base64_encode_alloc (const char *in, size_t inlen, char **out)
 119:base64url.c   **** {
 270              		.loc 1 119 1 is_stmt 1 view -0
 271              		.cfi_startproc
 272              		@ args = 0, pretend = 0, frame = 0
 273              		@ frame_needed = 0, uses_anonymous_args = 0
 274              		.loc 1 119 1 is_stmt 0 view .LVU83
 275 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 276              	.LCFI3:
 277              		.cfi_def_cfa_offset 24
 278              		.cfi_offset 4, -24
 279              		.cfi_offset 5, -20
 280              		.cfi_offset 6, -16
 281              		.cfi_offset 7, -12
 282              		.cfi_offset 8, -8
 283              		.cfi_offset 14, -4
 284 0004 1646     		mov	r6, r2
 120:base64url.c   ****   size_t outlen = 1 + BASE64_LENGTH (inlen);
 285              		.loc 1 120 3 is_stmt 1 view .LVU84
 286              		.loc 1 120 23 is_stmt 0 view .LVU85
 287 0006 8C1C     		adds	r4, r1, #2
 288 0008 0E4B     		ldr	r3, .L25
 289 000a A3FB0434 		umull	r3, r4, r3, r4
 290 000e 6408     		lsrs	r4, r4, #1
 291 0010 A400     		lsls	r4, r4, #2
 292              		.loc 1 120 10 view .LVU86
 293 0012 04F10108 		add	r8, r4, #1
 294              	.LVL32:
 121:base64url.c   **** 
 122:base64url.c   ****   /* Check for overflow in outlen computation.
 123:base64url.c   ****    *
 124:base64url.c   ****    * If there is no overflow, outlen >= inlen.
 125:base64url.c   ****    *
 126:base64url.c   ****    * If the operation (inlen + 2) overflows then it yields at most +1, so
 127:base64url.c   ****    * outlen is 0.
 128:base64url.c   ****    *
 129:base64url.c   ****    * If the multiplication overflows, we lose at least half of the
 130:base64url.c   ****    * correct value, so the result is < ((inlen + 2) / 3) * 2, which is
 131:base64url.c   ****    * less than (inlen + 2) * 0.66667, which is less than inlen as soon as
 132:base64url.c   ****    * (inlen > 4).
 133:base64url.c   ****    */
 134:base64url.c   ****   if (inlen > outlen)
 295              		.loc 1 134 3 is_stmt 1 view .LVU87
 296              		.loc 1 134 6 is_stmt 0 view .LVU88
 297 0016 4145     		cmp	r1, r8
 298 0018 04D9     		bls	.L21
 135:base64url.c   ****     {
 136:base64url.c   ****       *out = NULL;
 299              		.loc 1 136 7 is_stmt 1 view .LVU89
 300              		.loc 1 136 12 is_stmt 0 view .LVU90
 301 001a 0024     		movs	r4, #0
 302 001c 1460     		str	r4, [r2]
 137:base64url.c   ****       return 0;
 303              		.loc 1 137 7 is_stmt 1 view .LVU91
 304              	.LVL33:
 305              	.L20:
 138:base64url.c   ****     }
 139:base64url.c   **** 
 140:base64url.c   ****   *out = malloc (outlen);
 141:base64url.c   ****   if (!*out)
 142:base64url.c   ****     return outlen;
 143:base64url.c   **** 
 144:base64url.c   ****   base64_encode (in, inlen, *out, outlen);
 145:base64url.c   **** 
 146:base64url.c   ****   return outlen - 1;
 147:base64url.c   **** }
 306              		.loc 1 147 1 is_stmt 0 view .LVU92
 307 001e 2046     		mov	r0, r4
 308 0020 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 309              	.LVL34:
 310              	.L21:
 311              		.loc 1 147 1 view .LVU93
 312 0024 0746     		mov	r7, r0
 313 0026 0D46     		mov	r5, r1
 140:base64url.c   ****   if (!*out)
 314              		.loc 1 140 3 is_stmt 1 view .LVU94
 140:base64url.c   ****   if (!*out)
 315              		.loc 1 140 10 is_stmt 0 view .LVU95
 316 0028 4046     		mov	r0, r8
 317              	.LVL35:
 140:base64url.c   ****   if (!*out)
 318              		.loc 1 140 10 view .LVU96
 319 002a FFF7FEFF 		bl	malloc
 320              	.LVL36:
 140:base64url.c   ****   if (!*out)
 321              		.loc 1 140 10 view .LVU97
 322 002e 0246     		mov	r2, r0
 140:base64url.c   ****   if (!*out)
 323              		.loc 1 140 8 view .LVU98
 324 0030 3060     		str	r0, [r6]
 141:base64url.c   ****     return outlen;
 325              		.loc 1 141 3 is_stmt 1 view .LVU99
 141:base64url.c   ****     return outlen;
 326              		.loc 1 141 6 is_stmt 0 view .LVU100
 327 0032 28B1     		cbz	r0, .L23
 144:base64url.c   **** 
 328              		.loc 1 144 3 is_stmt 1 view .LVU101
 329 0034 4346     		mov	r3, r8
 330 0036 2946     		mov	r1, r5
 331 0038 3846     		mov	r0, r7
 332 003a FFF7FEFF 		bl	base64_encode
 333              	.LVL37:
 146:base64url.c   **** }
 334              		.loc 1 146 3 view .LVU102
 146:base64url.c   **** }
 335              		.loc 1 146 17 is_stmt 0 view .LVU103
 336 003e EEE7     		b	.L20
 337              	.L23:
 142:base64url.c   **** 
 338              		.loc 1 142 12 view .LVU104
 339 0040 4446     		mov	r4, r8
 340 0042 ECE7     		b	.L20
 341              	.L26:
 342              		.align	2
 343              	.L25:
 344 0044 ABAAAAAA 		.word	-1431655765
 345              		.cfi_endproc
 346              	.LFE2:
 348              		.section	.text.isbase64,"ax",%progbits
 349              		.align	1
 350              		.global	isbase64
 351              		.syntax unified
 352              		.thumb
 353              		.thumb_func
 354              		.fpu fpv4-sp-d16
 356              	isbase64:
 357              	.LVL38:
 358              	.LFB3:
 148:base64url.c   **** 
 149:base64url.c   **** /* With this approach this file works independent of the charset used
 150:base64url.c   ****    (think EBCDIC).  However, it does assume that the characters in the
 151:base64url.c   ****    Base64url alphabet (A-Z,a-z,0-9,-,_) are encoded in 0..255.  POSIX
 152:base64url.c   ****    1003.1-2001 require that char and unsigned char are 8-bit
 153:base64url.c   ****    quantities, though, taking care of that problem.  But this may be a
 154:base64url.c   ****    potential problem on non-POSIX C99 platforms.
 155:base64url.c   **** 
 156:base64url.c   ****    IBM C V6 for AIX mishandles "#define B64(x) ...'x'...", so use "_"
 157:base64url.c   ****    as the formal parameter rather than "x".  */
 158:base64url.c   **** #define B64(_)					\
 159:base64url.c   ****   ((_) == 'A' ? 0				\
 160:base64url.c   ****    : (_) == 'B' ? 1				\
 161:base64url.c   ****    : (_) == 'C' ? 2				\
 162:base64url.c   ****    : (_) == 'D' ? 3				\
 163:base64url.c   ****    : (_) == 'E' ? 4				\
 164:base64url.c   ****    : (_) == 'F' ? 5				\
 165:base64url.c   ****    : (_) == 'G' ? 6				\
 166:base64url.c   ****    : (_) == 'H' ? 7				\
 167:base64url.c   ****    : (_) == 'I' ? 8				\
 168:base64url.c   ****    : (_) == 'J' ? 9				\
 169:base64url.c   ****    : (_) == 'K' ? 10				\
 170:base64url.c   ****    : (_) == 'L' ? 11				\
 171:base64url.c   ****    : (_) == 'M' ? 12				\
 172:base64url.c   ****    : (_) == 'N' ? 13				\
 173:base64url.c   ****    : (_) == 'O' ? 14				\
 174:base64url.c   ****    : (_) == 'P' ? 15				\
 175:base64url.c   ****    : (_) == 'Q' ? 16				\
 176:base64url.c   ****    : (_) == 'R' ? 17				\
 177:base64url.c   ****    : (_) == 'S' ? 18				\
 178:base64url.c   ****    : (_) == 'T' ? 19				\
 179:base64url.c   ****    : (_) == 'U' ? 20				\
 180:base64url.c   ****    : (_) == 'V' ? 21				\
 181:base64url.c   ****    : (_) == 'W' ? 22				\
 182:base64url.c   ****    : (_) == 'X' ? 23				\
 183:base64url.c   ****    : (_) == 'Y' ? 24				\
 184:base64url.c   ****    : (_) == 'Z' ? 25				\
 185:base64url.c   ****    : (_) == 'a' ? 26				\
 186:base64url.c   ****    : (_) == 'b' ? 27				\
 187:base64url.c   ****    : (_) == 'c' ? 28				\
 188:base64url.c   ****    : (_) == 'd' ? 29				\
 189:base64url.c   ****    : (_) == 'e' ? 30				\
 190:base64url.c   ****    : (_) == 'f' ? 31				\
 191:base64url.c   ****    : (_) == 'g' ? 32				\
 192:base64url.c   ****    : (_) == 'h' ? 33				\
 193:base64url.c   ****    : (_) == 'i' ? 34				\
 194:base64url.c   ****    : (_) == 'j' ? 35				\
 195:base64url.c   ****    : (_) == 'k' ? 36				\
 196:base64url.c   ****    : (_) == 'l' ? 37				\
 197:base64url.c   ****    : (_) == 'm' ? 38				\
 198:base64url.c   ****    : (_) == 'n' ? 39				\
 199:base64url.c   ****    : (_) == 'o' ? 40				\
 200:base64url.c   ****    : (_) == 'p' ? 41				\
 201:base64url.c   ****    : (_) == 'q' ? 42				\
 202:base64url.c   ****    : (_) == 'r' ? 43				\
 203:base64url.c   ****    : (_) == 's' ? 44				\
 204:base64url.c   ****    : (_) == 't' ? 45				\
 205:base64url.c   ****    : (_) == 'u' ? 46				\
 206:base64url.c   ****    : (_) == 'v' ? 47				\
 207:base64url.c   ****    : (_) == 'w' ? 48				\
 208:base64url.c   ****    : (_) == 'x' ? 49				\
 209:base64url.c   ****    : (_) == 'y' ? 50				\
 210:base64url.c   ****    : (_) == 'z' ? 51				\
 211:base64url.c   ****    : (_) == '0' ? 52				\
 212:base64url.c   ****    : (_) == '1' ? 53				\
 213:base64url.c   ****    : (_) == '2' ? 54				\
 214:base64url.c   ****    : (_) == '3' ? 55				\
 215:base64url.c   ****    : (_) == '4' ? 56				\
 216:base64url.c   ****    : (_) == '5' ? 57				\
 217:base64url.c   ****    : (_) == '6' ? 58				\
 218:base64url.c   ****    : (_) == '7' ? 59				\
 219:base64url.c   ****    : (_) == '8' ? 60				\
 220:base64url.c   ****    : (_) == '9' ? 61				\
 221:base64url.c   ****    : (_) == '-' ? 62				\
 222:base64url.c   ****    : (_) == '_' ? 63				\
 223:base64url.c   ****    : -1)
 224:base64url.c   **** 
 225:base64url.c   **** static const signed char b64[0x100] = {
 226:base64url.c   ****   B64 (0), B64 (1), B64 (2), B64 (3),
 227:base64url.c   ****   B64 (4), B64 (5), B64 (6), B64 (7),
 228:base64url.c   ****   B64 (8), B64 (9), B64 (10), B64 (11),
 229:base64url.c   ****   B64 (12), B64 (13), B64 (14), B64 (15),
 230:base64url.c   ****   B64 (16), B64 (17), B64 (18), B64 (19),
 231:base64url.c   ****   B64 (20), B64 (21), B64 (22), B64 (23),
 232:base64url.c   ****   B64 (24), B64 (25), B64 (26), B64 (27),
 233:base64url.c   ****   B64 (28), B64 (29), B64 (30), B64 (31),
 234:base64url.c   ****   B64 (32), B64 (33), B64 (34), B64 (35),
 235:base64url.c   ****   B64 (36), B64 (37), B64 (38), B64 (39),
 236:base64url.c   ****   B64 (40), B64 (41), B64 (42), B64 (43),
 237:base64url.c   ****   B64 (44), B64 (45), B64 (46), B64 (47),
 238:base64url.c   ****   B64 (48), B64 (49), B64 (50), B64 (51),
 239:base64url.c   ****   B64 (52), B64 (53), B64 (54), B64 (55),
 240:base64url.c   ****   B64 (56), B64 (57), B64 (58), B64 (59),
 241:base64url.c   ****   B64 (60), B64 (61), B64 (62), B64 (63),
 242:base64url.c   ****   B64 (64), B64 (65), B64 (66), B64 (67),
 243:base64url.c   ****   B64 (68), B64 (69), B64 (70), B64 (71),
 244:base64url.c   ****   B64 (72), B64 (73), B64 (74), B64 (75),
 245:base64url.c   ****   B64 (76), B64 (77), B64 (78), B64 (79),
 246:base64url.c   ****   B64 (80), B64 (81), B64 (82), B64 (83),
 247:base64url.c   ****   B64 (84), B64 (85), B64 (86), B64 (87),
 248:base64url.c   ****   B64 (88), B64 (89), B64 (90), B64 (91),
 249:base64url.c   ****   B64 (92), B64 (93), B64 (94), B64 (95),
 250:base64url.c   ****   B64 (96), B64 (97), B64 (98), B64 (99),
 251:base64url.c   ****   B64 (100), B64 (101), B64 (102), B64 (103),
 252:base64url.c   ****   B64 (104), B64 (105), B64 (106), B64 (107),
 253:base64url.c   ****   B64 (108), B64 (109), B64 (110), B64 (111),
 254:base64url.c   ****   B64 (112), B64 (113), B64 (114), B64 (115),
 255:base64url.c   ****   B64 (116), B64 (117), B64 (118), B64 (119),
 256:base64url.c   ****   B64 (120), B64 (121), B64 (122), B64 (123),
 257:base64url.c   ****   B64 (124), B64 (125), B64 (126), B64 (127),
 258:base64url.c   ****   B64 (128), B64 (129), B64 (130), B64 (131),
 259:base64url.c   ****   B64 (132), B64 (133), B64 (134), B64 (135),
 260:base64url.c   ****   B64 (136), B64 (137), B64 (138), B64 (139),
 261:base64url.c   ****   B64 (140), B64 (141), B64 (142), B64 (143),
 262:base64url.c   ****   B64 (144), B64 (145), B64 (146), B64 (147),
 263:base64url.c   ****   B64 (148), B64 (149), B64 (150), B64 (151),
 264:base64url.c   ****   B64 (152), B64 (153), B64 (154), B64 (155),
 265:base64url.c   ****   B64 (156), B64 (157), B64 (158), B64 (159),
 266:base64url.c   ****   B64 (160), B64 (161), B64 (162), B64 (163),
 267:base64url.c   ****   B64 (164), B64 (165), B64 (166), B64 (167),
 268:base64url.c   ****   B64 (168), B64 (169), B64 (170), B64 (171),
 269:base64url.c   ****   B64 (172), B64 (173), B64 (174), B64 (175),
 270:base64url.c   ****   B64 (176), B64 (177), B64 (178), B64 (179),
 271:base64url.c   ****   B64 (180), B64 (181), B64 (182), B64 (183),
 272:base64url.c   ****   B64 (184), B64 (185), B64 (186), B64 (187),
 273:base64url.c   ****   B64 (188), B64 (189), B64 (190), B64 (191),
 274:base64url.c   ****   B64 (192), B64 (193), B64 (194), B64 (195),
 275:base64url.c   ****   B64 (196), B64 (197), B64 (198), B64 (199),
 276:base64url.c   ****   B64 (200), B64 (201), B64 (202), B64 (203),
 277:base64url.c   ****   B64 (204), B64 (205), B64 (206), B64 (207),
 278:base64url.c   ****   B64 (208), B64 (209), B64 (210), B64 (211),
 279:base64url.c   ****   B64 (212), B64 (213), B64 (214), B64 (215),
 280:base64url.c   ****   B64 (216), B64 (217), B64 (218), B64 (219),
 281:base64url.c   ****   B64 (220), B64 (221), B64 (222), B64 (223),
 282:base64url.c   ****   B64 (224), B64 (225), B64 (226), B64 (227),
 283:base64url.c   ****   B64 (228), B64 (229), B64 (230), B64 (231),
 284:base64url.c   ****   B64 (232), B64 (233), B64 (234), B64 (235),
 285:base64url.c   ****   B64 (236), B64 (237), B64 (238), B64 (239),
 286:base64url.c   ****   B64 (240), B64 (241), B64 (242), B64 (243),
 287:base64url.c   ****   B64 (244), B64 (245), B64 (246), B64 (247),
 288:base64url.c   ****   B64 (248), B64 (249), B64 (250), B64 (251),
 289:base64url.c   ****   B64 (252), B64 (253), B64 (254), B64 (255)
 290:base64url.c   **** };
 291:base64url.c   **** 
 292:base64url.c   **** #if UCHAR_MAX == 255
 293:base64url.c   **** # define uchar_in_range(c) true
 294:base64url.c   **** #else
 295:base64url.c   **** # define uchar_in_range(c) ((c) <= 255)
 296:base64url.c   **** #endif
 297:base64url.c   **** 
 298:base64url.c   **** /* Return true if CH is a character from the Base64 alphabet, and
 299:base64url.c   ****    false otherwise.  Note that '=' is padding and not considered to be
 300:base64url.c   ****    part of the alphabet.  */
 301:base64url.c   **** bool
 302:base64url.c   **** isbase64 (char ch)
 303:base64url.c   **** {
 359              		.loc 1 303 1 is_stmt 1 view -0
 360              		.cfi_startproc
 361              		@ args = 0, pretend = 0, frame = 0
 362              		@ frame_needed = 0, uses_anonymous_args = 0
 363              		@ link register save eliminated.
 304:base64url.c   ****   return uchar_in_range (to_uchar (ch)) && 0 <= b64[to_uchar (ch)];
 364              		.loc 1 304 3 view .LVU106
  63:base64url.c   **** }
 365              		.loc 1 63 3 view .LVU107
 366              		.loc 1 304 52 is_stmt 0 view .LVU108
 367 0000 034B     		ldr	r3, .L28
 368 0002 0344     		add	r3, r3, r0
 369              		.loc 1 304 41 view .LVU109
 370 0004 93F84000 		ldrb	r0, [r3, #64]	@ zero_extendqisi2
 371              	.LVL39:
 372              		.loc 1 304 41 view .LVU110
 373 0008 C043     		mvns	r0, r0
 305:base64url.c   **** }
 374              		.loc 1 305 1 view .LVU111
 375 000a C0F3C010 		ubfx	r0, r0, #7, #1
 376 000e 7047     		bx	lr
 377              	.L29:
 378              		.align	2
 379              	.L28:
 380 0010 00000000 		.word	.LANCHOR0
 381              		.cfi_endproc
 382              	.LFE3:
 384              		.section	.text.base64_decode,"ax",%progbits
 385              		.align	1
 386              		.global	base64_decode
 387              		.syntax unified
 388              		.thumb
 389              		.thumb_func
 390              		.fpu fpv4-sp-d16
 392              	base64_decode:
 393              	.LVL40:
 394              	.LFB4:
 306:base64url.c   **** 
 307:base64url.c   **** /* Decode base64 encoded input array IN of length INLEN to output
 308:base64url.c   ****    array OUT that can hold *OUTLEN bytes.  Return true if decoding was
 309:base64url.c   ****    successful, i.e. if the input was valid base64 data, false
 310:base64url.c   ****    otherwise.  If *OUTLEN is too small, as many bytes as possible will
 311:base64url.c   ****    be written to OUT.  On return, *OUTLEN holds the length of decoded
 312:base64url.c   ****    bytes in OUT.  Note that as soon as any non-alphabet characters are
 313:base64url.c   ****    encountered, decoding is stopped and false is returned.  This means
 314:base64url.c   ****    that, when applicable, you must remove any line terminators that is
 315:base64url.c   ****    part of the data stream before calling this function.  */
 316:base64url.c   **** bool
 317:base64url.c   **** base64_decode (const char *restrict in, size_t inlen,
 318:base64url.c   **** 	       char *restrict out, size_t *outlen)
 319:base64url.c   **** {
 395              		.loc 1 319 1 is_stmt 1 view -0
 396              		.cfi_startproc
 397              		@ args = 0, pretend = 0, frame = 0
 398              		@ frame_needed = 0, uses_anonymous_args = 0
 399              		.loc 1 319 1 is_stmt 0 view .LVU113
 400 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 401              	.LCFI4:
 402              		.cfi_def_cfa_offset 20
 403              		.cfi_offset 4, -20
 404              		.cfi_offset 5, -16
 405              		.cfi_offset 6, -12
 406              		.cfi_offset 7, -8
 407              		.cfi_offset 14, -4
 320:base64url.c   ****   size_t outleft = *outlen;
 408              		.loc 1 320 3 is_stmt 1 view .LVU114
 409              		.loc 1 320 10 is_stmt 0 view .LVU115
 410 0002 D3F800C0 		ldr	ip, [r3]
 411              	.LVL41:
 321:base64url.c   **** 
 322:base64url.c   ****   while (inlen >= 2)
 412              		.loc 1 322 3 is_stmt 1 view .LVU116
 413              		.loc 1 322 9 view .LVU117
 414 0006 0129     		cmp	r1, #1
 415 0008 4FD9     		bls	.L39
 320:base64url.c   ****   size_t outleft = *outlen;
 416              		.loc 1 320 10 is_stmt 0 view .LVU118
 417 000a 6446     		mov	r4, ip
 418              	.LBB36:
 419              	.LBB37:
 304:base64url.c   **** }
 420              		.loc 1 304 52 view .LVU119
 421 000c 284E     		ldr	r6, .L45
 422 000e 13E0     		b	.L38
 423              	.LVL42:
 424              	.L43:
 304:base64url.c   **** }
 425              		.loc 1 304 52 view .LVU120
 426              	.LBE37:
 427              	.LBE36:
 323:base64url.c   ****     {
 324:base64url.c   ****       if (!isbase64 (in[0]) || !isbase64 (in[1]))
 325:base64url.c   **** 	break;
 326:base64url.c   **** 
 327:base64url.c   ****       if (outleft)
 328:base64url.c   **** 	{
 329:base64url.c   **** 	  *out++ = ((b64[to_uchar (in[0])] << 2)
 330:base64url.c   **** 		    | (b64[to_uchar (in[1])] >> 4));
 331:base64url.c   **** 	  outleft--;
 332:base64url.c   **** 	}
 333:base64url.c   **** 
 334:base64url.c   ****       if (inlen == 2)
 335:base64url.c   **** 	break;
 336:base64url.c   **** 
 337:base64url.c   ****       if (in[2] == '=')
 338:base64url.c   **** 	{
 339:base64url.c   **** 	  if (inlen != 4)
 428              		.loc 1 339 4 is_stmt 1 view .LVU121
 429              		.loc 1 339 7 is_stmt 0 view .LVU122
 430 0010 0429     		cmp	r1, #4
 431 0012 03D1     		bne	.L31
 340:base64url.c   **** 	    break;
 341:base64url.c   **** 
 342:base64url.c   **** 	  if (in[3] != '=')
 432              		.loc 1 342 4 is_stmt 1 view .LVU123
 433              		.loc 1 342 7 is_stmt 0 view .LVU124
 434 0014 C278     		ldrb	r2, [r0, #3]	@ zero_extendqisi2
 435              	.LVL43:
 436              		.loc 1 342 7 view .LVU125
 437 0016 3D2A     		cmp	r2, #61
 438 0018 00D1     		bne	.L31
 439              	.L34:
 343:base64url.c   **** 	    break;
 344:base64url.c   **** 
 345:base64url.c   **** 	}
 346:base64url.c   ****       else
 347:base64url.c   **** 	{
 348:base64url.c   **** 	  if (!isbase64 (in[2]))
 349:base64url.c   **** 	    break;
 350:base64url.c   **** 
 351:base64url.c   **** 	  if (outleft)
 352:base64url.c   **** 	    {
 353:base64url.c   **** 	      *out++ = (((b64[to_uchar (in[1])] << 4) & 0xf0)
 354:base64url.c   **** 			| (b64[to_uchar (in[2])] >> 2));
 355:base64url.c   **** 	      outleft--;
 356:base64url.c   **** 	    }
 357:base64url.c   **** 
 358:base64url.c   **** 	  if (inlen == 3)
 359:base64url.c   **** 	    break;
 360:base64url.c   **** 
 361:base64url.c   **** 	  if (in[3] == '=')
 362:base64url.c   **** 	    {
 363:base64url.c   **** 	      if (inlen != 4)
 364:base64url.c   **** 		break;
 365:base64url.c   **** 	    }
 366:base64url.c   **** 	  else
 367:base64url.c   **** 	    {
 368:base64url.c   **** 	      if (!isbase64 (in[3]))
 369:base64url.c   **** 		break;
 370:base64url.c   **** 
 371:base64url.c   **** 	      if (outleft)
 372:base64url.c   **** 		{
 373:base64url.c   **** 		  *out++ = (((b64[to_uchar (in[2])] << 6) & 0xc0)
 374:base64url.c   **** 			    | b64[to_uchar (in[3])]);
 375:base64url.c   **** 		  outleft--;
 376:base64url.c   **** 		}
 377:base64url.c   **** 	    }
 378:base64url.c   **** 	}
 379:base64url.c   **** 
 380:base64url.c   ****       in += 4;
 440              		.loc 1 380 7 is_stmt 1 view .LVU126
 441              	.LVL44:
 381:base64url.c   ****       inlen -= 4;
 442              		.loc 1 381 7 view .LVU127
 443              		.loc 1 381 13 is_stmt 0 view .LVU128
 444 001a 0439     		subs	r1, r1, #4
 445              	.LVL45:
 322:base64url.c   ****     {
 446              		.loc 1 322 9 is_stmt 1 view .LVU129
 447              	.L31:
 382:base64url.c   ****     }
 383:base64url.c   **** 
 384:base64url.c   ****   *outlen -= outleft;
 448              		.loc 1 384 3 view .LVU130
 449              		.loc 1 384 11 is_stmt 0 view .LVU131
 450 001c ACEB0404 		sub	r4, ip, r4
 451              	.LVL46:
 452              		.loc 1 384 11 view .LVU132
 453 0020 1C60     		str	r4, [r3]
 385:base64url.c   **** 
 386:base64url.c   ****   if (inlen != 0)
 454              		.loc 1 386 3 is_stmt 1 view .LVU133
 455 0022 B1FA81F0 		clz	r0, r1
 456 0026 4009     		lsrs	r0, r0, #5
 387:base64url.c   ****     return false;
 388:base64url.c   **** 
 389:base64url.c   ****   return true;
 390:base64url.c   **** }
 457              		.loc 1 390 1 is_stmt 0 view .LVU134
 458 0028 F0BD     		pop	{r4, r5, r6, r7, pc}
 459              	.LVL47:
 460              	.L44:
 363:base64url.c   **** 		break;
 461              		.loc 1 363 8 is_stmt 1 view .LVU135
 363:base64url.c   **** 		break;
 462              		.loc 1 363 11 is_stmt 0 view .LVU136
 463 002a 0429     		cmp	r1, #4
 464 002c F5D0     		beq	.L34
 363:base64url.c   **** 		break;
 465              		.loc 1 363 11 view .LVU137
 466 002e F5E7     		b	.L31
 467              	.L37:
 380:base64url.c   ****       inlen -= 4;
 468              		.loc 1 380 7 is_stmt 1 view .LVU138
 469              	.LVL48:
 380:base64url.c   ****       inlen -= 4;
 470              		.loc 1 380 10 is_stmt 0 view .LVU139
 471 0030 0430     		adds	r0, r0, #4
 472              	.LVL49:
 381:base64url.c   ****     }
 473              		.loc 1 381 7 is_stmt 1 view .LVU140
 381:base64url.c   ****     }
 474              		.loc 1 381 13 is_stmt 0 view .LVU141
 475 0032 0439     		subs	r1, r1, #4
 476              	.LVL50:
 322:base64url.c   ****     {
 477              		.loc 1 322 9 is_stmt 1 view .LVU142
 478 0034 0129     		cmp	r1, #1
 479 0036 F1D9     		bls	.L31
 480              	.L38:
 324:base64url.c   **** 	break;
 481              		.loc 1 324 7 view .LVU143
 482              	.LVL51:
 483              	.LBB40:
 484              	.LBI36:
 302:base64url.c   **** {
 485              		.loc 1 302 1 view .LVU144
 486              	.LBB38:
 304:base64url.c   **** }
 487              		.loc 1 304 3 view .LVU145
 304:base64url.c   **** }
 488              		.loc 1 304 3 is_stmt 0 view .LVU146
 489              	.LBE38:
 490              	.LBE40:
  63:base64url.c   **** }
 491              		.loc 1 63 3 is_stmt 1 view .LVU147
 492              	.LBB41:
 493              	.LBB39:
 304:base64url.c   **** }
 494              		.loc 1 304 53 is_stmt 0 view .LVU148
 495 0038 0578     		ldrb	r5, [r0]	@ zero_extendqisi2
 304:base64url.c   **** }
 496              		.loc 1 304 52 view .LVU149
 497 003a 3544     		add	r5, r5, r6
 498 003c 95F940E0 		ldrsb	lr, [r5, #64]
 499              	.LVL52:
 304:base64url.c   **** }
 500              		.loc 1 304 52 view .LVU150
 501              	.LBE39:
 502              	.LBE41:
 324:base64url.c   **** 	break;
 503              		.loc 1 324 10 view .LVU151
 504 0040 BEF1000F 		cmp	lr, #0
 505 0044 EADB     		blt	.L31
 506              	.LVL53:
 507              	.LBB42:
 508              	.LBI42:
 302:base64url.c   **** {
 509              		.loc 1 302 1 is_stmt 1 discriminator 1 view .LVU152
 510              	.LBB43:
 304:base64url.c   **** }
 511              		.loc 1 304 3 discriminator 1 view .LVU153
 304:base64url.c   **** }
 512              		.loc 1 304 3 is_stmt 0 discriminator 1 view .LVU154
 513              	.LBE43:
 514              	.LBE42:
  63:base64url.c   **** }
 515              		.loc 1 63 3 is_stmt 1 discriminator 1 view .LVU155
 516              	.LBB45:
 517              	.LBB44:
 304:base64url.c   **** }
 518              		.loc 1 304 53 is_stmt 0 discriminator 1 view .LVU156
 519 0046 4578     		ldrb	r5, [r0, #1]	@ zero_extendqisi2
 304:base64url.c   **** }
 520              		.loc 1 304 52 discriminator 1 view .LVU157
 521 0048 3544     		add	r5, r5, r6
 522 004a 95F94070 		ldrsb	r7, [r5, #64]
 523              	.LVL54:
 304:base64url.c   **** }
 524              		.loc 1 304 52 discriminator 1 view .LVU158
 525              	.LBE44:
 526              	.LBE45:
 324:base64url.c   **** 	break;
 527              		.loc 1 324 29 discriminator 1 view .LVU159
 528 004e 002F     		cmp	r7, #0
 529 0050 E4DB     		blt	.L31
 327:base64url.c   **** 	{
 530              		.loc 1 327 7 is_stmt 1 view .LVU160
 327:base64url.c   **** 	{
 531              		.loc 1 327 10 is_stmt 0 view .LVU161
 532 0052 2CB1     		cbz	r4, .L32
 329:base64url.c   **** 		    | (b64[to_uchar (in[1])] >> 4));
 533              		.loc 1 329 4 is_stmt 1 view .LVU162
 534              	.LVL55:
  63:base64url.c   **** }
 535              		.loc 1 63 3 view .LVU163
  63:base64url.c   **** }
 536              		.loc 1 63 3 view .LVU164
 330:base64url.c   **** 	  outleft--;
 537              		.loc 1 330 7 is_stmt 0 view .LVU165
 538 0054 3D11     		asrs	r5, r7, #4
 539 0056 45EA8E0E 		orr	lr, r5, lr, lsl #2
 329:base64url.c   **** 		    | (b64[to_uchar (in[1])] >> 4));
 540              		.loc 1 329 11 view .LVU166
 541 005a 02F801EB 		strb	lr, [r2], #1
 542              	.LVL56:
 331:base64url.c   **** 	}
 543              		.loc 1 331 4 is_stmt 1 view .LVU167
 331:base64url.c   **** 	}
 544              		.loc 1 331 11 is_stmt 0 view .LVU168
 545 005e 013C     		subs	r4, r4, #1
 546              	.LVL57:
 547              	.L32:
 334:base64url.c   **** 	break;
 548              		.loc 1 334 7 is_stmt 1 view .LVU169
 334:base64url.c   **** 	break;
 549              		.loc 1 334 10 is_stmt 0 view .LVU170
 550 0060 0229     		cmp	r1, #2
 551 0062 DBD0     		beq	.L31
 337:base64url.c   **** 	{
 552              		.loc 1 337 7 is_stmt 1 view .LVU171
 337:base64url.c   **** 	{
 553              		.loc 1 337 13 is_stmt 0 view .LVU172
 554 0064 8578     		ldrb	r5, [r0, #2]	@ zero_extendqisi2
 337:base64url.c   **** 	{
 555              		.loc 1 337 10 view .LVU173
 556 0066 3D2D     		cmp	r5, #61
 557 0068 D2D0     		beq	.L43
 348:base64url.c   **** 	    break;
 558              		.loc 1 348 4 is_stmt 1 view .LVU174
 559              	.LVL58:
 560              	.LBB46:
 561              	.LBI46:
 302:base64url.c   **** {
 562              		.loc 1 302 1 view .LVU175
 563              	.LBB47:
 304:base64url.c   **** }
 564              		.loc 1 304 3 view .LVU176
 304:base64url.c   **** }
 565              		.loc 1 304 3 is_stmt 0 view .LVU177
 566              	.LBE47:
 567              	.LBE46:
  63:base64url.c   **** }
 568              		.loc 1 63 3 is_stmt 1 view .LVU178
 569              	.LBB49:
 570              	.LBB48:
 304:base64url.c   **** }
 571              		.loc 1 304 52 is_stmt 0 view .LVU179
 572 006a 3544     		add	r5, r5, r6
 573              	.LVL59:
 304:base64url.c   **** }
 574              		.loc 1 304 52 view .LVU180
 575 006c 95F940E0 		ldrsb	lr, [r5, #64]
 576              	.LVL60:
 304:base64url.c   **** }
 577              		.loc 1 304 52 view .LVU181
 578              	.LBE48:
 579              	.LBE49:
 348:base64url.c   **** 	    break;
 580              		.loc 1 348 7 view .LVU182
 581 0070 BEF1000F 		cmp	lr, #0
 582 0074 D2DB     		blt	.L31
 351:base64url.c   **** 	    {
 583              		.loc 1 351 4 is_stmt 1 view .LVU183
 351:base64url.c   **** 	    {
 584              		.loc 1 351 7 is_stmt 0 view .LVU184
 585 0076 34B1     		cbz	r4, .L35
 353:base64url.c   **** 			| (b64[to_uchar (in[2])] >> 2));
 586              		.loc 1 353 8 is_stmt 1 view .LVU185
 587              	.LVL61:
  63:base64url.c   **** }
 588              		.loc 1 63 3 view .LVU186
  63:base64url.c   **** }
 589              		.loc 1 63 3 view .LVU187
 354:base64url.c   **** 	      outleft--;
 590              		.loc 1 354 4 is_stmt 0 view .LVU188
 591 0078 4FEAAE05 		asr	r5, lr, #2
 592 007c 45EA0717 		orr	r7, r5, r7, lsl #4
 353:base64url.c   **** 			| (b64[to_uchar (in[2])] >> 2));
 593              		.loc 1 353 15 view .LVU189
 594 0080 02F8017B 		strb	r7, [r2], #1
 595              	.LVL62:
 355:base64url.c   **** 	    }
 596              		.loc 1 355 8 is_stmt 1 view .LVU190
 355:base64url.c   **** 	    }
 597              		.loc 1 355 15 is_stmt 0 view .LVU191
 598 0084 013C     		subs	r4, r4, #1
 599              	.LVL63:
 600              	.L35:
 358:base64url.c   **** 	    break;
 601              		.loc 1 358 4 is_stmt 1 view .LVU192
 358:base64url.c   **** 	    break;
 602              		.loc 1 358 7 is_stmt 0 view .LVU193
 603 0086 0329     		cmp	r1, #3
 604 0088 C8D0     		beq	.L31
 361:base64url.c   **** 	    {
 605              		.loc 1 361 4 is_stmt 1 view .LVU194
 361:base64url.c   **** 	    {
 606              		.loc 1 361 10 is_stmt 0 view .LVU195
 607 008a C578     		ldrb	r5, [r0, #3]	@ zero_extendqisi2
 361:base64url.c   **** 	    {
 608              		.loc 1 361 7 view .LVU196
 609 008c 3D2D     		cmp	r5, #61
 610 008e CCD0     		beq	.L44
 368:base64url.c   **** 		break;
 611              		.loc 1 368 8 is_stmt 1 view .LVU197
 612              	.LVL64:
 613              	.LBB50:
 614              	.LBI50:
 302:base64url.c   **** {
 615              		.loc 1 302 1 view .LVU198
 616              	.LBB51:
 304:base64url.c   **** }
 617              		.loc 1 304 3 view .LVU199
 304:base64url.c   **** }
 618              		.loc 1 304 3 is_stmt 0 view .LVU200
 619              	.LBE51:
 620              	.LBE50:
  63:base64url.c   **** }
 621              		.loc 1 63 3 is_stmt 1 view .LVU201
 622              	.LBB53:
 623              	.LBB52:
 304:base64url.c   **** }
 624              		.loc 1 304 52 is_stmt 0 view .LVU202
 625 0090 3544     		add	r5, r5, r6
 626              	.LVL65:
 304:base64url.c   **** }
 627              		.loc 1 304 52 view .LVU203
 628 0092 95F94050 		ldrsb	r5, [r5, #64]
 629              	.LVL66:
 304:base64url.c   **** }
 630              		.loc 1 304 52 view .LVU204
 631              	.LBE52:
 632              	.LBE53:
 368:base64url.c   **** 		break;
 633              		.loc 1 368 11 view .LVU205
 634 0096 002D     		cmp	r5, #0
 635 0098 C0DB     		blt	.L31
 371:base64url.c   **** 		{
 636              		.loc 1 371 8 is_stmt 1 view .LVU206
 371:base64url.c   **** 		{
 637              		.loc 1 371 11 is_stmt 0 view .LVU207
 638 009a 002C     		cmp	r4, #0
 639 009c C8D0     		beq	.L37
 373:base64url.c   **** 			    | b64[to_uchar (in[3])]);
 640              		.loc 1 373 5 is_stmt 1 view .LVU208
 641              	.LVL67:
  63:base64url.c   **** }
 642              		.loc 1 63 3 view .LVU209
  63:base64url.c   **** }
 643              		.loc 1 63 3 view .LVU210
 374:base64url.c   **** 		  outleft--;
 644              		.loc 1 374 8 is_stmt 0 view .LVU211
 645 009e 45EA8E1E 		orr	lr, r5, lr, lsl #6
 373:base64url.c   **** 			    | b64[to_uchar (in[3])]);
 646              		.loc 1 373 12 view .LVU212
 647 00a2 02F801EB 		strb	lr, [r2], #1
 648              	.LVL68:
 375:base64url.c   **** 		}
 649              		.loc 1 375 5 is_stmt 1 view .LVU213
 375:base64url.c   **** 		}
 650              		.loc 1 375 12 is_stmt 0 view .LVU214
 651 00a6 013C     		subs	r4, r4, #1
 652              	.LVL69:
 375:base64url.c   **** 		}
 653              		.loc 1 375 12 view .LVU215
 654 00a8 C2E7     		b	.L37
 655              	.LVL70:
 656              	.L39:
 320:base64url.c   **** 
 657              		.loc 1 320 10 view .LVU216
 658 00aa 6446     		mov	r4, ip
 659 00ac B6E7     		b	.L31
 660              	.L46:
 661 00ae 00BF     		.align	2
 662              	.L45:
 663 00b0 00000000 		.word	.LANCHOR0
 664              		.cfi_endproc
 665              	.LFE4:
 667              		.section	.text.base64_decode_alloc,"ax",%progbits
 668              		.align	1
 669              		.global	base64_decode_alloc
 670              		.syntax unified
 671              		.thumb
 672              		.thumb_func
 673              		.fpu fpv4-sp-d16
 675              	base64_decode_alloc:
 676              	.LVL71:
 677              	.LFB5:
 391:base64url.c   **** 
 392:base64url.c   **** /* Allocate an output buffer in *OUT, and decode the base64 encoded
 393:base64url.c   ****    data stored in IN of size INLEN to the *OUT buffer.  On return, the
 394:base64url.c   ****    size of the decoded data is stored in *OUTLEN.  OUTLEN may be NULL,
 395:base64url.c   ****    if the caller is not interested in the decoded length.  *OUT may be
 396:base64url.c   ****    NULL to indicate an out of memory error, in which case *OUTLEN
 397:base64url.c   ****    contains the size of the memory block needed.  The function returns
 398:base64url.c   ****    true on successful decoding and memory allocation errors.  (Use the
 399:base64url.c   ****    *OUT and *OUTLEN parameters to differentiate between successful
 400:base64url.c   ****    decoding and memory error.)  The function returns false if the
 401:base64url.c   ****    input was invalid, in which case *OUT is NULL and *OUTLEN is
 402:base64url.c   ****    undefined. */
 403:base64url.c   **** bool
 404:base64url.c   **** base64_decode_alloc (const char *in, size_t inlen, char **out,
 405:base64url.c   **** 		     size_t *outlen)
 406:base64url.c   **** {
 678              		.loc 1 406 1 is_stmt 1 view -0
 679              		.cfi_startproc
 680              		@ args = 0, pretend = 0, frame = 8
 681              		@ frame_needed = 0, uses_anonymous_args = 0
 682              		.loc 1 406 1 is_stmt 0 view .LVU218
 683 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 684              	.LCFI5:
 685              		.cfi_def_cfa_offset 24
 686              		.cfi_offset 4, -24
 687              		.cfi_offset 5, -20
 688              		.cfi_offset 6, -16
 689              		.cfi_offset 7, -12
 690              		.cfi_offset 8, -8
 691              		.cfi_offset 14, -4
 692 0004 82B0     		sub	sp, sp, #8
 693              	.LCFI6:
 694              		.cfi_def_cfa_offset 32
 695 0006 8046     		mov	r8, r0
 696 0008 0D46     		mov	r5, r1
 697 000a 1646     		mov	r6, r2
 698 000c 1F46     		mov	r7, r3
 407:base64url.c   ****   /* This may allocate a few bytes too much, depending on input,
 408:base64url.c   ****      but it's not worth the extra CPU time to compute the exact amount.
 409:base64url.c   ****      The exact amount is 3 * inlen / 4, minus 1 if the input ends
 410:base64url.c   ****      with "=" and minus another 1 if the input ends with "==".
 411:base64url.c   ****      Dividing before multiplying avoids the possibility of overflow.  */
 412:base64url.c   ****   size_t needlen = 3 * (inlen / 4) + 2;
 699              		.loc 1 412 3 is_stmt 1 view .LVU219
 700              		.loc 1 412 31 is_stmt 0 view .LVU220
 701 000e 8C08     		lsrs	r4, r1, #2
 702              		.loc 1 412 22 view .LVU221
 703 0010 04EB4404 		add	r4, r4, r4, lsl #1
 704              		.loc 1 412 36 view .LVU222
 705 0014 A01C     		adds	r0, r4, #2
 706              	.LVL72:
 707              		.loc 1 412 10 view .LVU223
 708 0016 0190     		str	r0, [sp, #4]
 413:base64url.c   **** 
 414:base64url.c   ****   *out = malloc (needlen);
 709              		.loc 1 414 3 is_stmt 1 view .LVU224
 710              		.loc 1 414 10 is_stmt 0 view .LVU225
 711 0018 FFF7FEFF 		bl	malloc
 712              	.LVL73:
 713              		.loc 1 414 8 view .LVU226
 714 001c 3060     		str	r0, [r6]
 415:base64url.c   ****   if (!*out)
 715              		.loc 1 415 3 is_stmt 1 view .LVU227
 716              		.loc 1 415 6 is_stmt 0 view .LVU228
 717 001e A0B1     		cbz	r0, .L50
 718 0020 0246     		mov	r2, r0
 416:base64url.c   ****     return true;
 417:base64url.c   **** 
 418:base64url.c   ****   if (!base64_decode (in, inlen, *out, &needlen))
 719              		.loc 1 418 3 is_stmt 1 view .LVU229
 720              		.loc 1 418 8 is_stmt 0 view .LVU230
 721 0022 01AB     		add	r3, sp, #4
 722 0024 2946     		mov	r1, r5
 723 0026 4046     		mov	r0, r8
 724 0028 FFF7FEFF 		bl	base64_decode
 725              	.LVL74:
 726              		.loc 1 418 6 view .LVU231
 727 002c 0446     		mov	r4, r0
 728 002e 30B1     		cbz	r0, .L52
 419:base64url.c   ****     {
 420:base64url.c   ****       free (*out);
 421:base64url.c   ****       *out = NULL;
 422:base64url.c   ****       return false;
 423:base64url.c   ****     }
 424:base64url.c   **** 
 425:base64url.c   ****   if (outlen)
 729              		.loc 1 425 3 is_stmt 1 view .LVU232
 730              		.loc 1 425 6 is_stmt 0 view .LVU233
 731 0030 0FB1     		cbz	r7, .L48
 426:base64url.c   ****     *outlen = needlen;
 732              		.loc 1 426 5 is_stmt 1 view .LVU234
 733              		.loc 1 426 13 is_stmt 0 view .LVU235
 734 0032 019B     		ldr	r3, [sp, #4]
 735 0034 3B60     		str	r3, [r7]
 736              	.L48:
 427:base64url.c   **** 
 428:base64url.c   ****   return true;
 429:base64url.c   **** }
 737              		.loc 1 429 1 view .LVU236
 738 0036 2046     		mov	r0, r4
 739 0038 02B0     		add	sp, sp, #8
 740              	.LCFI7:
 741              		.cfi_remember_state
 742              		.cfi_def_cfa_offset 24
 743              		@ sp needed
 744 003a BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 745              	.LVL75:
 746              	.L52:
 747              	.LCFI8:
 748              		.cfi_restore_state
 420:base64url.c   ****       *out = NULL;
 749              		.loc 1 420 7 is_stmt 1 view .LVU237
 750 003e 3068     		ldr	r0, [r6]
 751 0040 FFF7FEFF 		bl	free
 752              	.LVL76:
 421:base64url.c   ****       return false;
 753              		.loc 1 421 7 view .LVU238
 421:base64url.c   ****       return false;
 754              		.loc 1 421 12 is_stmt 0 view .LVU239
 755 0044 0023     		movs	r3, #0
 756 0046 3360     		str	r3, [r6]
 422:base64url.c   ****     }
 757              		.loc 1 422 7 is_stmt 1 view .LVU240
 422:base64url.c   ****     }
 758              		.loc 1 422 14 is_stmt 0 view .LVU241
 759 0048 F5E7     		b	.L48
 760              	.L50:
 416:base64url.c   **** 
 761              		.loc 1 416 12 view .LVU242
 762 004a 0124     		movs	r4, #1
 763 004c F3E7     		b	.L48
 764              		.cfi_endproc
 765              	.LFE5:
 767              		.section	.rodata
 768              		.align	2
 769              		.set	.LANCHOR0,. + 0
 772              	b64str.6139:
 773 0000 41424344 		.ascii	"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxy"
 773      45464748 
 773      494A4B4C 
 773      4D4E4F50 
 773      51525354 
 774 0033 7A303132 		.ascii	"z0123456789-_"
 774      33343536 
 774      3738392D 
 774      5F
 777              	b64:
 778 0040 FFFFFFFF 		.ascii	"\377\377\377\377\377\377\377\377\377\377\377\377\377"
 778      FFFFFFFF 
 778      FFFFFFFF 
 778      FF
 779 004d FFFFFFFF 		.ascii	"\377\377\377\377\377\377\377\377\377\377\377\377\377"
 779      FFFFFFFF 
 779      FFFFFFFF 
 779      FF
 780 005a FFFFFFFF 		.ascii	"\377\377\377\377\377\377\377\377\377\377\377\377\377"
 780      FFFFFFFF 
 780      FFFFFFFF 
 780      FF
 781 0067 FFFFFFFF 		.ascii	"\377\377\377\377\377\377>\377\377456789:;<=\377\377"
 781      FFFF3EFF 
 781      FF343536 
 781      3738393A 
 781      3B3C3DFF 
 782 007c FFFFFFFF 		.ascii	"\377\377\377\377\377\000\001\002\003\004\005\006\007"
 782      FF000102 
 782      03040506 
 782      07
 783 0089 08090A0B 		.ascii	"\010\011\012\013\014\015\016\017\020\021\022\023\024"
 783      0C0D0E0F 
 783      10111213 
 783      14
 784 0096 15161718 		.ascii	"\025\026\027\030\031\377\377\377\377?\377\032\033\034"
 784      19FFFFFF 
 784      FF3FFF1A 
 784      1B1C
 785 00a4 1D1E1F20 		.ascii	"\035\036\037 !\"#$%&'()*+,-./0123\377\377\377\377\377"
 785      21222324 
 785      25262728 
 785      292A2B2C 
 785      2D2E2F30 
 786 00c0 FFFFFFFF 		.ascii	"\377\377\377\377\377\377\377\377\377\377\377\377\377"
 786      FFFFFFFF 
 786      FFFFFFFF 
 786      FF
 787 00cd FFFFFFFF 		.ascii	"\377\377\377\377\377\377\377\377\377\377\377\377\377"
 787      FFFFFFFF 
 787      FFFFFFFF 
 787      FF
 788 00da FFFFFFFF 		.ascii	"\377\377\377\377\377\377\377\377\377\377\377\377\377"
 788      FFFFFFFF 
 788      FFFFFFFF 
 788      FF
 789 00e7 FFFFFFFF 		.ascii	"\377\377\377\377\377\377\377\377\377\377\377\377\377"
 789      FFFFFFFF 
 789      FFFFFFFF 
 789      FF
 790 00f4 FFFFFFFF 		.ascii	"\377\377\377\377\377\377\377\377\377\377\377\377\377"
 790      FFFFFFFF 
 790      FFFFFFFF 
 790      FF
 791 0101 FFFFFFFF 		.ascii	"\377\377\377\377\377\377\377\377\377\377\377\377\377"
 791      FFFFFFFF 
 791      FFFFFFFF 
 791      FF
 792 010e FFFFFFFF 		.ascii	"\377\377\377\377\377\377\377\377\377\377\377\377\377"
 792      FFFFFFFF 
 792      FFFFFFFF 
 792      FF
 793 011b FFFFFFFF 		.ascii	"\377\377\377\377\377\377\377\377\377\377\377\377\377"
 793      FFFFFFFF 
 793      FFFFFFFF 
 793      FF
 794 0128 FFFFFFFF 		.ascii	"\377\377\377\377\377\377\377\377\377\377\377\377\377"
 794      FFFFFFFF 
 794      FFFFFFFF 
 794      FF
 795 0135 FFFFFFFF 		.ascii	"\377\377\377\377\377\377\377\377\377\377\377"
 795      FFFFFFFF 
 795      FFFFFF
 796              		.text
 797              	.Letext0:
 798              		.file 2 "/usr/lib/gcc/arm-none-eabi/9.2.1/include/stddef.h"
 799              		.file 3 "/usr/include/newlib/sys/_types.h"
 800              		.file 4 "/usr/include/newlib/sys/reent.h"
 801              		.file 5 "/usr/include/newlib/sys/lock.h"
 802              		.file 6 "/usr/include/newlib/stdlib.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 base64url.c
     /tmp/ccRwyoKb.s:17     .text.base64_encode:0000000000000000 $t
     /tmp/ccRwyoKb.s:25     .text.base64_encode:0000000000000000 base64_encode
     /tmp/ccRwyoKb.s:255    .text.base64_encode:00000000000000bc $d
     /tmp/ccRwyoKb.s:260    .text.base64_encode_alloc:0000000000000000 $t
     /tmp/ccRwyoKb.s:267    .text.base64_encode_alloc:0000000000000000 base64_encode_alloc
     /tmp/ccRwyoKb.s:344    .text.base64_encode_alloc:0000000000000044 $d
     /tmp/ccRwyoKb.s:349    .text.isbase64:0000000000000000 $t
     /tmp/ccRwyoKb.s:356    .text.isbase64:0000000000000000 isbase64
     /tmp/ccRwyoKb.s:380    .text.isbase64:0000000000000010 $d
     /tmp/ccRwyoKb.s:385    .text.base64_decode:0000000000000000 $t
     /tmp/ccRwyoKb.s:392    .text.base64_decode:0000000000000000 base64_decode
     /tmp/ccRwyoKb.s:663    .text.base64_decode:00000000000000b0 $d
     /tmp/ccRwyoKb.s:668    .text.base64_decode_alloc:0000000000000000 $t
     /tmp/ccRwyoKb.s:675    .text.base64_decode_alloc:0000000000000000 base64_decode_alloc
     /tmp/ccRwyoKb.s:768    .rodata:0000000000000000 $d
     /tmp/ccRwyoKb.s:772    .rodata:0000000000000000 b64str.6139
     /tmp/ccRwyoKb.s:777    .rodata:0000000000000040 b64
                           .group:0000000000000000 wm4.0.2b1621af4d156004b207f1d62b99413e
                           .group:0000000000000000 wm4.stdbool.h.29.07dce69c3b78884144b7f7bd19483461
                           .group:0000000000000000 wm4.stddef.h.39.27677723d43e5b5a7afdf8d798429f1d
                           .group:0000000000000000 wm4.base64url.h.26.ed1fee22e760dd991443f292d5830091
                           .group:0000000000000000 wm4.ieeefp.h.77.f33a4dce62116f6f5175ff8bae57a54c
                           .group:0000000000000000 wm4._newlib_version.h.4.1ef4e12f167f8b69d7c30054be56050d
                           .group:0000000000000000 wm4.newlib.h.21.1ae2897bc09bbe4bc80ffb801fb02432
                           .group:0000000000000000 wm4.features.h.22.026edb2397769f4ae13f35900dbdb560
                           .group:0000000000000000 wm4.config.h.224.c701144a7b0518c6ee9b9b5465b79f81
                           .group:0000000000000000 wm4._ansi.h.31.de524f58584151836e90d8620a16f8e8
                           .group:0000000000000000 wm4.stdlib.h.13.4ed386f5c1a80d71e72172885d946ef2
                           .group:0000000000000000 wm4.stddef.h.155.ba788add86a0e365f264484f110c3c29
                           .group:0000000000000000 wm4._types.h.20.dd0d04dca3800a0d2a6129b87f3adbb2
                           .group:0000000000000000 wm4.stddef.h.155.3588ebfdd1e8c7ede80509bb9c3b8009
                           .group:0000000000000000 wm4._default_types.h.6.959254cf5f09734ea7516c89e8bb21bd
                           .group:0000000000000000 wm4._types.h.127.34941de1b2539d59d5cac00e0dd27a45
                           .group:0000000000000000 wm4.reent.h.17.e292bf8b0bec6c96e131a54347145a30
                           .group:0000000000000000 wm4.lock.h.2.c0958401bd0ce484d507ee19aacab817
                           .group:0000000000000000 wm4.reent.h.77.dcd6129ff07fe81bd5636db29abe53b2
                           .group:0000000000000000 wm4.cdefs.h.49.2bf373aedffd8b393ccd11dc057e8547
                           .group:0000000000000000 wm4.alloca.h.8.dfc0c703c47ec3e69746825b17d9e66d
                           .group:0000000000000000 wm4.stdlib.h.56.f4862cfbf4363a1db01842d5bdf72c18
                           .group:0000000000000000 wm4.limits.h.25.cf8422693d16b226d0307cb8be7d4408

UNDEFINED SYMBOLS
malloc
free
